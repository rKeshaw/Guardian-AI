# import asyncio
# import json
# import logging
# from typing import Dict, List, Any, Optional
# from datetime import datetime

# from guardian.agents.base_agent import BaseAgent
# from guardian.core.ai_client import ai_client, AIPersona
# from guardian.core.config import settings

# logger = logging.getLogger(__name__)

# class VulnerabilityAnalysisAgent(BaseAgent):
#     """
#     Agent 2: Vulnerability Analysis and Classification
    
#     Capabilities:
#     - OWASP Top 10 2023 vulnerability classification
#     - Security strength assessment (1-10 scale)
#     - Risk prioritization and scoring
#     - Attack vector identification
#     - Business impact analysis
#     - Exploitation difficulty rating
#     """
    
#     def __init__(self, db):
#         super().__init__(db, "VulnerabilityAnalysisAgent")
#         self.owasp_categories = self._load_owasp_categories()
    
#     def _load_owasp_categories(self) -> Dict[str, Dict[str, Any]]:
#         """Load OWASP Top 10 2023 categories with analysis patterns"""
#         return {
#             "A01:2023": {
#                 "name": "Broken Access Control",
#                 "description": "Violations of the principle of least privilege or deny by default",
#                 "common_indicators": [
#                     "Missing authorization checks",
#                     "Insecure direct object references", 
#                     "Path traversal vulnerabilities",
#                     "CORS misconfigurations",
#                     "Elevation of privilege"
#                 ],
#                 "technical_tests": [
#                     "Authorization bypass attempts",
#                     "Privilege escalation testing",
#                     "IDOR parameter manipulation",
#                     "Directory traversal payloads"
#                 ]
#             },
#             "A02:2023": {
#                 "name": "Cryptographic Failures", 
#                 "description": "Failures related to cryptography which often leads to sensitive data exposure",
#                 "common_indicators": [
#                     "Weak encryption algorithms",
#                     "Hard-coded cryptographic keys",
#                     "Improper certificate validation",
#                     "Insufficient entropy"
#                 ],
#                 "technical_tests": [
#                     "SSL/TLS configuration analysis",
#                     "Certificate validation testing",
#                     "Encryption algorithm identification",
#                     "Key management assessment"
#                 ]
#             },
#             "A03:2023": {
#                 "name": "Injection",
#                 "description": "User-supplied data is not validated, filtered, or sanitized",
#                 "common_indicators": [
#                     "SQL injection points",
#                     "NoSQL injection vulnerabilities",
#                     "Command injection flaws",
#                     "LDAP injection",
#                     "XPath injection"
#                 ],
#                 "technical_tests": [
#                     "SQL injection payloads",
#                     "Command injection attempts", 
#                     "Template injection testing",
#                     "Script injection validation"
#                 ]
#             },
#             "A04:2023": {
#                 "name": "Insecure Design",
#                 "description": "Risks related to design flaws and architectural weaknesses",
#                 "common_indicators": [
#                     "Missing security controls",
#                     "Insufficient threat modeling",
#                     "Insecure architecture patterns",
#                     "Business logic flaws"
#                 ],
#                 "technical_tests": [
#                     "Business logic bypass",
#                     "Workflow manipulation",
#                     "Rate limiting assessment",
#                     "Security control validation"
#                 ]
#             },
#             "A05:2023": {
#                 "name": "Security Misconfiguration",
#                 "description": "Missing appropriate security hardening configurations",
#                 "common_indicators": [
#                     "Default configurations",
#                     "Incomplete configurations",
#                     "Open cloud storage",
#                     "Verbose error messages",
#                     "Disabled security features"
#                 ],
#                 "technical_tests": [
#                     "Configuration file access",
#                     "Directory listing attempts",
#                     "Error message analysis",
#                     "Security header validation"
#                 ]
#             },
#             "A06:2023": {
#                 "name": "Vulnerable and Outdated Components",
#                 "description": "Components with known vulnerabilities",
#                 "common_indicators": [
#                     "Outdated libraries",
#                     "Vulnerable frameworks",
#                     "Unpatched components", 
#                     "Unsupported software versions"
#                 ],
#                 "technical_tests": [
#                     "Component version detection",
#                     "CVE database matching",
#                     "Dependency analysis",
#                     "Patch level assessment"
#                 ]
#             },
#             "A07:2023": {
#                 "name": "Identification and Authentication Failures",
#                 "description": "Application functions related to authentication and session management",
#                 "common_indicators": [
#                     "Weak password policies",
#                     "Session fixation",
#                     "Insufficient session timeout",
#                     "Credential stuffing vulnerabilities"
#                 ],
#                 "technical_tests": [
#                     "Authentication bypass attempts",
#                     "Session management testing",
#                     "Password policy validation",
#                     "Multi-factor authentication assessment"
#                 ]
#             },
#             "A08:2023": {
#                 "name": "Software and Data Integrity Failures",
#                 "description": "Code and infrastructure that do not protect against integrity violations",
#                 "common_indicators": [
#                     "Unsigned software updates",
#                     "Insecure deserialization",
#                     "Untrusted CI/CD pipelines",
#                     "Auto-update mechanisms"
#                 ],
#                 "technical_tests": [
#                     "Deserialization payload testing",
#                     "Software integrity verification",
#                     "Supply chain analysis",
#                     "Update mechanism assessment"
#                 ]
#             },
#             "A09:2023": {
#                 "name": "Security Logging and Monitoring Failures",
#                 "description": "Insufficient logging and monitoring capabilities",
#                 "common_indicators": [
#                     "Missing audit logs",
#                     "Insufficient log monitoring",
#                     "No incident response",
#                     "Attackable log/monitoring infrastructure"
#                 ],
#                 "technical_tests": [
#                     "Log injection attempts",
#                     "Event logging validation",
#                     "Monitoring system assessment",
#                     "Incident response testing"
#                 ]
#             },
#             "A10:2023": {
#                 "name": "Server-Side Request Forgery (SSRF)",
#                 "description": "SSRF flaws occur whenever a web application fetches a remote resource",
#                 "common_indicators": [
#                     "URL parameter manipulation",
#                     "Internal network access",
#                     "Cloud metadata service access",
#                     "Port scanning capabilities"
#                 ],
#                 "technical_tests": [
#                     "SSRF payload injection",
#                     "Internal service enumeration",
#                     "Cloud metadata extraction",
#                     "Network reconnaissance"
#                 ]
#             }
#         }
    
#     async def execute(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
#         """Execute comprehensive vulnerability analysis"""
#         task_id = await self._start_task(task_data)
#         session_id = task_data.get("session_id", "unknown")
        
#         try:
#             recon_data = task_data.get("reconnaissance_data", {})
#             config = task_data.get("config", {})
            
#             results = {
#                 "task_id": task_id,
#                 "analysis_timestamp": datetime.utcnow().isoformat(),
#                 "vulnerability_assessment": {}
#             }
            
#             # Analyze each target from reconnaissance
#             for target_url, target_recon in recon_data.get("reconnaissance_data", {}).items():
#                 target_analysis = await self._analyze_target_vulnerabilities(
#                     target_url, target_recon, config
#                 )
#                 results["vulnerability_assessment"][target_url] = target_analysis
            
#             # Overall risk assessment
#             overall_assessment = await self._calculate_overall_risk(results["vulnerability_assessment"])
#             results["overall_risk_assessment"] = overall_assessment
            
#             # AI-powered vulnerability analysis
#             ai_analysis = await self._ai_vulnerability_analysis(results)
#             results["ai_analysis"] = ai_analysis
            
#             await self._complete_task(results, session_id)
#             return results
            
#         except Exception as e:
#             await self._handle_error(e, session_id)
#             raise
    
#     async def _analyze_target_vulnerabilities(
#         self, 
#         target_url: str, 
#         recon_data: Dict[str, Any], 
#         config: Dict[str, Any]
#     ) -> Dict[str, Any]:
#         """Analyze specific target for OWASP Top 10 vulnerabilities"""
        
#         logger.info(f"Analyzing vulnerabilities for {target_url}")
        
#         vulnerabilities = []
        
#         # Analyze each OWASP category
#         for owasp_id, owasp_info in self.owasp_categories.items():
#             vuln_analysis = await self._assess_owasp_category(
#                 target_url, recon_data, owasp_id, owasp_info
#             )
            
#             if vuln_analysis["potential_vulnerability"]:
#                 vulnerabilities.append(vuln_analysis)
        
#         # Calculate overall security score
#         security_scores = [v["security_level"] for v in vulnerabilities if v["potential_vulnerability"]]
#         overall_security_score = sum(security_scores) / len(security_scores) if security_scores else 10.0
        
#         return {
#             "target_url": target_url,
#             "vulnerabilities": vulnerabilities,
#             "overall_security_score": overall_security_score,
#             "high_priority_vulns": [v for v in vulnerabilities if v["risk_level"] in ["Critical", "High"]],
#             "attack_complexity": self._calculate_attack_complexity(vulnerabilities),
#             "business_impact": self._assess_business_impact(vulnerabilities, recon_data)
#         }
    
#     async def _assess_owasp_category(
#         self, 
#         target_url: str, 
#         recon_data: Dict[str, Any], 
#         owasp_id: str, 
#         owasp_info: Dict[str, Any]
#     ) -> Dict[str, Any]:
#         """Assess specific OWASP category for target"""
        
#         # Technology-based vulnerability indicators
#         potential_vuln = False
#         security_level = 10  # Start with maximum security assumption
#         indicators = []
        
#         technologies = recon_data.get("technologies", {})
#         endpoints = recon_data.get("endpoints", [])
#         open_ports = recon_data.get("open_ports", [])
        
#         # Category-specific analysis
#         if owasp_id == "A01:2023":  # Broken Access Control
#             admin_indicators = ["admin", "panel", "dashboard", "api", "management"]
#             for endpoint in endpoints:
#                 if any(indicator in endpoint.lower() for indicator in admin_indicators):
#                     potential_vuln = True
#                     security_level = min(security_level, 6)
#                     indicators.append(f"Administrative endpoint detected: {endpoint}")
        
#         elif owasp_id == "A02:2023":  # Cryptographic Failures
#             if target_url.startswith("http://"):
#                 potential_vuln = True
#                 security_level = min(security_level, 3)
#                 indicators.append("HTTP protocol detected (no encryption)")
            
#             weak_ports = [21, 23, 25, 110, 143]
#             for port_info in open_ports:
#                 if port_info.get("port") in weak_ports:
#                     potential_vuln = True
#                     security_level = min(security_level, 4)
#                     indicators.append(f"Insecure service on port {port_info['port']}")
        
#         elif owasp_id == "A03:2023":  # Injection
#             db_indicators = ["mysql", "postgresql", "mongodb", "sql", "database"]
#             if any(any(db in str(tech).lower() for db in db_indicators) 
#                    for tech_list in technologies.values() for tech in tech_list):
#                 potential_vuln = True
#                 security_level = min(security_level, 5)
#                 indicators.append("Database technology detected")
            
#             form_endpoints = [ep for ep in endpoints if "form" in ep.lower() or "search" in ep.lower()]
#             if form_endpoints:
#                 potential_vuln = True
#                 security_level = min(security_level, 6)
#                 indicators.append(f"Form endpoints detected: {len(form_endpoints)}")
        
#         elif owasp_id == "A05:2023":  # Security Misconfiguration
#             debug_indicators = ["debug", "test", "dev", "staging"]
#             for endpoint in endpoints:
#                 if any(indicator in endpoint.lower() for indicator in debug_indicators):
#                     potential_vuln = True
#                     security_level = min(security_level, 4)
#                     indicators.append(f"Development endpoint exposed: {endpoint}")
        
#         elif owasp_id == "A06:2023":  # Vulnerable Components
#             for tech_type, tech_list in technologies.items():
#                 for tech in tech_list:
#                     if any(old_version in str(tech).lower() 
#                            for old_version in ["2019", "2020", "2021"]):
#                         potential_vuln = True
#                         security_level = min(security_level, 5)
#                         indicators.append(f"Potentially outdated technology: {tech}")
        
#         # Default risk assessment
#         if potential_vuln:
#             if security_level <= 3:
#                 risk_level = "Critical"
#             elif security_level <= 5:
#                 risk_level = "High"
#             elif security_level <= 7:
#                 risk_level = "Medium"
#             else:
#                 risk_level = "Low"
#         else:
#             risk_level = "None"
        
#         return {
#             "owasp_category": owasp_id,
#             "vulnerability_name": owasp_info["name"],
#             "potential_vulnerability": potential_vuln,
#             "security_level": security_level,
#             "risk_level": risk_level,
#             "indicators": indicators,
#             "technical_tests_recommended": owasp_info["technical_tests"],
#             "exploitation_difficulty": self._assess_exploitation_difficulty(security_level),
#             "business_impact_potential": self._assess_category_business_impact(owasp_id)
#         }
    
#     def _assess_exploitation_difficulty(self, security_level: int) -> str:
#         """Assess how difficult it would be to exploit"""
#         if security_level <= 3:
#             return "Very Easy"
#         elif security_level <= 5:
#             return "Easy"
#         elif security_level <= 7:
#             return "Medium"
#         elif security_level <= 8:
#             return "Hard"
#         else:
#             return "Very Hard"
    
#     def _assess_category_business_impact(self, owasp_id: str) -> str:
#         """Assess potential business impact of OWASP category"""
#         high_impact_categories = ["A01:2023", "A02:2023", "A03:2023", "A07:2023"]
#         medium_impact_categories = ["A04:2023", "A05:2023", "A06:2023", "A10:2023"]
        
#         if owasp_id in high_impact_categories:
#             return "High"
#         elif owasp_id in medium_impact_categories:
#             return "Medium"
#         else:
#             return "Low"
    
#     def _calculate_attack_complexity(self, vulnerabilities: List[Dict[str, Any]]) -> str:
#         """Calculate overall attack complexity"""
#         if not vulnerabilities:
#             return "Very High"
        
#         avg_security_level = sum(v["security_level"] for v in vulnerabilities) / len(vulnerabilities)
        
#         if avg_security_level <= 3:
#             return "Very Low"
#         elif avg_security_level <= 5:
#             return "Low"
#         elif avg_security_level <= 7:
#             return "Medium"
#         elif avg_security_level <= 8:
#             return "High"
#         else:
#             return "Very High"
    
#     def _assess_business_impact(self, vulnerabilities: List[Dict[str, Any]], recon_data: Dict[str, Any]) -> str:
#         """Assess overall business impact"""
#         if not vulnerabilities:
#             return "None"
        
#         critical_vulns = [v for v in vulnerabilities if v["risk_level"] == "Critical"]
#         high_vulns = [v for v in vulnerabilities if v["risk_level"] == "High"]
        
#         if critical_vulns:
#             return "Critical"
#         elif len(high_vulns) >= 2:
#             return "High" 
#         elif high_vulns:
#             return "Medium"
#         else:
#             return "Low"
    
#     async def _calculate_overall_risk(self, vulnerability_assessments: Dict[str, Any]) -> Dict[str, Any]:
#         """Calculate overall risk across all targets"""
        
#         all_vulnerabilities = []
#         target_count = len(vulnerability_assessments)
        
#         for target_assessment in vulnerability_assessments.values():
#             all_vulnerabilities.extend(target_assessment.get("vulnerabilities", []))
        
#         if not all_vulnerabilities:
#             return {
#                 "overall_risk_level": "Low",
#                 "total_vulnerabilities": 0,
#                 "risk_distribution": {},
#                 "recommendations": ["Continue monitoring", "Implement baseline security controls"]
#             }
        
#         # Risk distribution
#         risk_counts = {}
#         for vuln in all_vulnerabilities:
#             risk_level = vuln["risk_level"]
#             risk_counts[risk_level] = risk_counts.get(risk_level, 0) + 1
        
#         # Overall risk calculation
#         if risk_counts.get("Critical", 0) > 0:
#             overall_risk = "Critical"
#         elif risk_counts.get("High", 0) >= 2:
#             overall_risk = "High"
#         elif risk_counts.get("High", 0) > 0 or risk_counts.get("Medium", 0) >= 3:
#             overall_risk = "Medium"
#         else:
#             overall_risk = "Low"
        
#         return {
#             "overall_risk_level": overall_risk,
#             "total_vulnerabilities": len(all_vulnerabilities),
#             "targets_analyzed": target_count,
#             "risk_distribution": risk_counts,
#             "avg_security_score": sum(v["security_level"] for v in all_vulnerabilities) / len(all_vulnerabilities),
#             "priority_targets": self._identify_priority_targets(vulnerability_assessments)
#         }
    
#     def _identify_priority_targets(self, assessments: Dict[str, Any]) -> List[Dict[str, Any]]:
#         """Identify highest priority targets"""
#         priority_targets = []
        
#         for target_url, assessment in assessments.items():
#             critical_vulns = len([v for v in assessment.get("vulnerabilities", []) 
#                                 if v["risk_level"] == "Critical"])
#             high_vulns = len([v for v in assessment.get("vulnerabilities", []) 
#                             if v["risk_level"] == "High"])
            
#             priority_score = critical_vulns * 10 + high_vulns * 5
            
#             if priority_score > 0:
#                 priority_targets.append({
#                     "target_url": target_url,
#                     "priority_score": priority_score,
#                     "critical_vulnerabilities": critical_vulns,
#                     "high_vulnerabilities": high_vulns,
#                     "security_score": assessment.get("overall_security_score", 10)
#                 })
        
#         # Sort by priority score
#         priority_targets.sort(key=lambda x: x["priority_score"], reverse=True)
        
#         return priority_targets[:5]  # Top 5 priority targets
    
#     async def _ai_vulnerability_analysis(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
#         """AI-powered comprehensive vulnerability analysis"""
#         logger.info("Performing AI vulnerability analysis")
        
#         try:
#             ai_analysis = await ai_client.analyze_vulnerability(
#                 target_data=analysis_results,
#                 reconnaissance_results=analysis_results.get("reconnaissance_data", {})
#             )
            
#             return ai_analysis
            
#         except Exception as e:
#             logger.error(f"AI vulnerability analysis failed: {str(e)}")
#             return {"error": "AI analysis failed", "message": str(e)}


import asyncio
import json
import os
import logging
from typing import Dict, Any, List

from guardian.agents.base_agent import BaseAgent
from guardian.core.ai_client import ai_client, AIPersona
from guardian.core.config import settings

logger = logging.getLogger(__name__)

class VulnerabilityAnalysisAgent(BaseAgent):
    """
    Agent 2: AI-Driven Vulnerability Analysis and Classification.
    This agent delegates its analytical tasks to a powerful language model
    using a master prompt.
    """
    
    def __init__(self, db):
        super().__init__(db, "VulnerabilityAnalysisAgent")

    async def execute(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Executes the AI-driven vulnerability analysis workflow."""
        task_id = await self._start_task(task_data)
        session_id = task_data.get("session_id", "unknown")
        
        try:
            recon_data = task_data.get("reconnaissance_data", {})
            logger.info("🤖 VulnHunter is delegating analysis to the AI core...")

            # The entire analysis is now performed by the AI
            ai_generated_assessment = await self._ai_driven_analysis(recon_data)

            results = {
                "task_id": task_id,
                "analysis_timestamp": self.get_status().get("last_activity"),
                "vulnerability_assessment": ai_generated_assessment,
                "ai_analysis": ai_generated_assessment,
                "source": "AI-Driven Analysis"
            }

            await self._complete_task(results, session_id)
            return results
            
        except Exception as e:
            await self._handle_error(e, session_id)
            raise
        
    def _get_knowledge_base_files(self) -> List[str]:
        """Scans the PayloadsAllTheThings directory for relevant markdown files."""
        knowledge_base_path = os.path.join(settings.PAYLOADS_REPO_PATH, "Methodology and Resources")
        available_files = []
        try:
            if os.path.isdir(knowledge_base_path):
                for filename in os.listdir(knowledge_base_path):
                    if filename.endswith(".md"):
                        available_files.append(filename)
            logger.info(f"Discovered {len(available_files)} knowledge base files.")
        except Exception as e:
            logger.error(f"Failed to scan knowledge base directory: {e}")
        return available_files

    async def _ai_driven_analysis(self, recon_results: Dict[str, Any]) -> Dict[str, Any]:
        """
        Crafts a master prompt with reconnaissance data and queries the AI
        to perform the entire vulnerability analysis.
        """
        knowledge_files = self._get_knowledge_base_files()
        knowledge_files_str = "\n".join(f"- {f}" for f in knowledge_files)
        master_prompt = f"""
You are "VulnHunter", a meticulous cybersecurity analysis engine. Your task is to analyze reconnaissance data, identify potential vulnerabilities, and classify them against an existing knowledge base. You follow formatting instructions with perfect precision. Your output MUST be ONLY a valid JSON object.

== CONTEXT 1: RECONNAISSANCE REPORT ==
{json.dumps(recon_results, indent=2)}

== CONTEXT 2: AVAILABLE KNOWLEDGE BASE FILES ==
You have access to the following list of knowledge files:
{knowledge_files_str}

== TASK ==
Based on the reconnaissance report, perform the following steps:
1.  Identify all potential OWASP Top 10 vulnerabilities.
2.  For each vulnerability you identify, you MUST match it to the most relevant filename from the `AVAILABLE KNOWLEDGE BASE FILES` list provided above.
3.  CRITICAL RULE: Do NOT invent new filenames. If no file from the list is a suitable match for a vulnerability you have found, you MUST use the value `null` for the "knowledge_base_file" key.

== OUTPUT FORMAT ==
You must return your findings as a single, valid JSON object adhering to this exact structure:
{{
  "overall_risk_level": "...",
  "vulnerabilities": [
    {{
      "vulnerability_name": "...",
      "owasp_category": "...",
      "risk_level": "...",
      "reasoning": "...",
      "attack_vectors": ["..."],
      "knowledge_base_file": "A single, exact filename from the list provided in CONTEXT 2, or null."
    }}
  ]
}}
"""

        ai_response_str = await ai_client.query_ai(
            master_prompt,
            persona=AIPersona.VULNERABILITY_EXPERT
        )

        if not ai_response_str:
            logger.error("AI returned an empty response.")
            return {"error": "AI returned an empty response."}
        
        # --- NEW ROBUST JSON PARSING LOGIC ---
        try:
            # Find the start of the JSON object
            json_start_index = ai_response_str.find('{')
            # Find the end of the JSON object
            json_end_index = ai_response_str.rfind('}') + 1
            
            if json_start_index != -1 and json_end_index != -1:
                # Extract the JSON part of the string
                clean_json_str = ai_response_str[json_start_index:json_end_index]
                return json.loads(clean_json_str)
            else:
                raise json.JSONDecodeError("Could not find JSON object in AI response.", ai_response_str, 0)

        except json.JSONDecodeError:
            logger.error(f"Failed to decode AI response into JSON. Raw response: {ai_response_str}")
            return {"error": "AI returned malformed JSON.", "raw_response": ai_response_str}